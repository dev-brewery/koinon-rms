# Auth State Fix Summary - Issue #34

## Problems Fixed

### 1. BLOCKER: User State Null After Token Refresh (AuthContext.tsx:102)
**Problem**: After successful token refresh, user state was set to `null` with a TODO comment about fetching from `/me` endpoint. This caused authenticated users to lose their user data during automatic token refresh.

**Root Cause**: The `RefreshResponse` type only includes `accessToken`, `refreshToken`, and `expiresAt` - it does NOT include user data. The refresh endpoint is designed only to rotate tokens, not return user information.

**Solution**: Changed `refreshAuth()` to preserve existing user state instead of nullifying it. The user data remains valid after token refresh since it was originally set during login.

**Changes**:
```typescript
// Before (line 102):
setState({
  user: null, // User data should be fetched from /me endpoint
  isAuthenticated: true,
  isLoading: false,
});

// After (lines 121-126):
setState(prev => ({
  ...prev,  // Preserve existing user data
  isAuthenticated: true,
  isLoading: false,
  error: null,
}));
```

### 2. Race Condition on Mount
**Problem**: The `useEffect` included `refreshAuth` in its dependency array, causing potential infinite loops and multiple simultaneous auth checks on component mount.

**Solution**:
- Added `hasCheckedAuth` ref to track if initial auth check has completed
- Removed `refreshAuth` from dependency array (empty array now)
- Added ESLint disable comment with explanation

**Changes**:
```typescript
// Added ref (line 50):
const hasCheckedAuth = useRef(false);

// Updated useEffect (lines 142-164):
useEffect(() => {
  // Prevent race condition - only check auth once on mount
  if (hasCheckedAuth.current) {
    return;
  }
  hasCheckedAuth.current = true;
  // ... rest of logic
  // eslint-disable-next-line react-hooks/exhaustive-deps
}, []); // Empty dependency array
```

### 3. Login Errors Not Propagated
**Problem**: When login failed, the `isLoading` state remained `true` and errors weren't tracked in AuthContext state, causing poor UX.

**Solution**:
- Added `error` field to `AuthState` interface
- Wrapped login logic in try/catch
- Set `isLoading: false` and store error message on failure
- Re-throw error so LoginForm can still handle it locally

**Changes**:
```typescript
// Added to AuthState (line 18):
error: string | null;

// Updated login function (lines 56-77):
const login = useCallback(async (request: LoginRequest) => {
  setState(prev => ({ ...prev, isLoading: true, error: null }));

  try {
    const response = await authApi.login(request);
    setState({
      user: response.user,
      isAuthenticated: true,
      isLoading: false,
      error: null,
    });
  } catch (error) {
    setState({
      user: null,
      isAuthenticated: false,
      isLoading: false,
      error: error instanceof Error ? error.message : 'Login failed',
    });
    throw error; // Re-throw for LoginForm
  }
}, []);
```

### 4. Missing Error Boundary
**Problem**: No React ErrorBoundary to catch and handle unexpected errors gracefully.

**Solution**:
- Created new `ErrorBoundary` component with:
  - Class component implementation (required for error boundaries)
  - User-friendly error UI
  - "Try Again" and "Go Home" actions
  - Development-only error details display
  - Proper error logging hooks
- Wrapped App routes with ErrorBoundary

**New Files**:
- `/home/mbrewer/projects/koinon-rms/src/web/src/components/ErrorBoundary.tsx`

**Changes to App.tsx**:
```typescript
import { ErrorBoundary } from './components/ErrorBoundary';

function App() {
  return (
    <ErrorBoundary>
      <Routes>
        {/* ... routes */}
      </Routes>
    </ErrorBoundary>
  );
}
```

## Files Modified

1. `/home/mbrewer/projects/koinon-rms/src/web/src/contexts/AuthContext.tsx`
   - Fixed user state preservation during token refresh
   - Added race condition protection with `hasCheckedAuth` ref
   - Added error handling to login function
   - Added `error` field to state

2. `/home/mbrewer/projects/koinon-rms/src/web/src/App.tsx`
   - Added ErrorBoundary import
   - Wrapped routes with ErrorBoundary

3. `/home/mbrewer/projects/koinon-rms/src/web/src/components/ErrorBoundary.tsx` (NEW)
   - Complete error boundary implementation
   - User-friendly error UI
   - Development error details

## Testing

### Pre-existing Test Status
- Build has pre-existing TypeScript errors in `client.ts` and `validators.ts` (unrelated to auth changes)
- Test suite runs successfully: `useIdleTimeout.test.ts` passes (13 tests)
- One test file has dependency issue: `IdleWarningModal.test.tsx` (pre-existing)

### Manual Testing Recommendations
1. **Token Refresh Flow**:
   - Login successfully
   - Wait for token to expire (or manually trigger 401)
   - Verify user data persists after automatic refresh

2. **Login Error Handling**:
   - Attempt login with invalid credentials
   - Verify loading state returns to false
   - Verify error message displays

3. **Mount Race Condition**:
   - Refresh page multiple times
   - Check network tab for duplicate auth checks
   - Verify only one refresh call on mount

4. **Error Boundary**:
   - Trigger a React error (e.g., throw in render)
   - Verify error boundary catches and displays error UI
   - Verify "Try Again" and "Go Home" buttons work

## Important Notes

### Token Storage Behavior
Tokens are stored **in-memory only** (not localStorage) for security. This means:
- On page refresh, all auth state (tokens + user) is lost
- Users must log in again after page refresh
- This is intentional for security (prevents XSS attacks)

The mount check for existing tokens is useful for:
- Token refresh during same browser session (e.g., after 401 response)
- NOT useful after page refresh (tokens won't exist)

### API Contract Alignment
The fix aligns with the actual API contract in `docs/reference/api-contracts.md`:
- `TokenResponse` (from login) includes `user: UserSummaryDto`
- `RefreshResponse` (from refresh) does NOT include user data
- Only tokens are rotated during refresh, user data stays in React state

## Security Considerations
- Tokens remain in memory only (not persisted)
- No sensitive data logged to console
- Error messages don't expose system internals
- Error boundary prevents full app crashes
