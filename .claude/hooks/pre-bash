#!/bin/bash
# MAXIMUS Pre-bash hook
# Enforces MCP-first for file operations, blocks dangerous commands

set -euo pipefail

# Load validation library
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
if [[ -f "${SCRIPT_DIR}/lib/validation.sh" ]]; then
    source "${SCRIPT_DIR}/lib/validation.sh"
else
    # Minimal logging if validation.sh not found
    log_error() { echo "[ERROR] $*" >&2; }
    log_info() { echo "[INFO] $*" >&2; }
    log_warning() { echo "[WARN] $*" >&2; }
    log_success() { echo "[OK] $*" >&2; }
fi

# Read JSON from stdin
INPUT=$(cat)
COMMAND=$(echo "$INPUT" | python3 -c "import sys,json; print(json.load(sys.stdin).get('tool_input',{}).get('command',''))" 2>/dev/null || echo "")

if [[ -z "$COMMAND" ]]; then
    log_error "No command provided"
    exit 2
fi

EXIT_CODE=0

# ============================================================================
# MCP-FIRST ENFORCEMENT (CRITICAL FOR TOKEN SAVINGS)
# ============================================================================
# Block bash file operations - use MCPs instead
# $600 in bash tool calls in 3 days is unacceptable

# Block: cat -> mcp__filesystem__read_text_file
if echo "$COMMAND" | grep -qE "^cat\s+[^|>]+" && ! echo "$COMMAND" | grep -qE "\|"; then
    log_error "BLOCKED: Use mcp__filesystem__read_text_file instead of cat"
    log_info "Command: $COMMAND"
    EXIT_CODE=2
fi

# Block: head/tail -> mcp__filesystem__read_text_file with params
if echo "$COMMAND" | grep -qE "^(head|tail)\s+[^|]+" && ! echo "$COMMAND" | grep -qE "\|"; then
    log_error "BLOCKED: Use mcp__filesystem__read_text_file with head/tail param"
    log_info "Command: $COMMAND"
    EXIT_CODE=2
fi

# Block: grep/rg -> Grep tool
if echo "$COMMAND" | grep -qE "^(grep|rg)\s+"; then
    log_error "BLOCKED: Use Grep tool instead of bash grep/rg"
    log_info "Command: $COMMAND"
    EXIT_CODE=2
fi

# Block: find -> Glob tool
if echo "$COMMAND" | grep -qE "^find\s+"; then
    log_error "BLOCKED: Use Glob tool instead of find"
    log_info "Command: $COMMAND"
    EXIT_CODE=2
fi

# Block: ls -la -> mcp__filesystem__list_directory
if echo "$COMMAND" | grep -qE "^ls\s+-[la]"; then
    log_error "BLOCKED: Use mcp__filesystem__list_directory instead of ls"
    log_info "Command: $COMMAND"
    EXIT_CODE=2
fi

# ============================================================================
# DANGEROUS COMMAND PREVENTION
# ============================================================================

# Block force push to main/master
if echo "$COMMAND" | grep -qE "git push.*(-f|--force)" && \
   echo "$COMMAND" | grep -qE "(main|master)"; then
    log_error "BLOCKED: Force push to main/master"
    EXIT_CODE=2
fi

# Block hard reset
if echo "$COMMAND" | grep -qE "git reset --hard"; then
    log_warning "WARNING: Hard reset is destructive"
fi

# Block deletion of protected branches
if echo "$COMMAND" | grep -qE "git branch -D (main|master|develop)"; then
    log_error "BLOCKED: Cannot delete protected branches"
    EXIT_CODE=2
fi

# Block rm -rf on critical directories
if echo "$COMMAND" | grep -qE "rm -rf.*(src|docs|tests|\.git)"; then
    log_error "BLOCKED: Cannot delete critical directories"
    EXIT_CODE=2
fi

# ============================================================================
# WORKFLOW FILE PROTECTION (CI CHEAT PREVENTION)
# ============================================================================
# Agents often try to "fix" CI failures by weakening the CI config instead of
# fixing the actual code. This is ALWAYS wrong.

if echo "$COMMAND" | grep -qE "^git commit"; then
    # Check if workflow files are staged
    if git diff --cached --name-only 2>/dev/null | grep -qE '^\.github/workflows/.*\.(yml|yaml)$'; then
        # Check for CI bypass patterns in the diff
        WORKFLOW_DIFF=$(git diff --cached -- '.github/workflows/*.yml' '.github/workflows/*.yaml' 2>/dev/null || true)

        if echo "$WORKFLOW_DIFF" | grep -qE '^\+.*continue-on-error:\s*true'; then
            log_error "BLOCKED: Cannot add 'continue-on-error: true' to workflows"
            log_error "This hides failures instead of fixing them."
            log_error "Fix the APPLICATION CODE, not the CI config."
            EXIT_CODE=2
        fi

        if echo "$WORKFLOW_DIFF" | grep -qE '^\+.*fail-on-error:\s*false'; then
            log_error "BLOCKED: Cannot add 'fail-on-error: false' to workflows"
            log_error "This lets tests fail silently."
            log_error "Fix the APPLICATION CODE, not the CI config."
            EXIT_CODE=2
        fi

        if echo "$WORKFLOW_DIFF" | grep -qE '^\+.*--no-verify|^\+.*--skip-tests'; then
            log_error "BLOCKED: Cannot add test-skipping flags to workflows"
            log_error "Fix the APPLICATION CODE, not the CI config."
            EXIT_CODE=2
        fi

        # Warn about any workflow changes (may be legitimate, but suspicious)
        if [[ $EXIT_CODE -eq 0 ]]; then
            log_warning "WARNING: Workflow file changes detected"
            log_warning "Ensure this is a legitimate CI improvement, not a workaround for failing code."
            log_warning "If CI is failing: FIX THE CODE, not the workflow."
        fi
    fi
fi

# ============================================================================
# ALLOWED COMMANDS
# ============================================================================
# - git (operations not covered by MCP)
# - dotnet, npm, docker (build tools)
# - piped commands (complex operations)

if [[ $EXIT_CODE -ne 0 ]]; then
    log_error "Pre-bash validation FAILED"
    exit $EXIT_CODE
fi

exit 0
