# EF Core Migration Safety in CI/CD - Best Practices Guide

## Overview

This document outlines best practices for managing Entity Framework Core migrations in a continuous integration environment, specifically tailored for Koinon RMS.

## Architecture Decision: Local Tool Manifest

### Why `.config/dotnet-tools.json`?

**Before (Problematic):**
```yaml
dotnet tool update --global dotnet-ef --version 8.0.11 || dotnet tool install --global dotnet-ef --version 8.0.11
```

**After (Best Practice):**
```yaml
dotnet tool restore  # Reads .config/dotnet-tools.json
```

### Benefits

| Aspect | Local Manifest | Global Installation |
|--------|---------------|--------------------|
| Version Management | Explicit, version-controlled | Implicit, prone to drift |
| Consistency | Same across dev/test/prod | Can differ between environments |
| Isolation | Project-scoped | System-wide pollution |
| Reproducibility | Guaranteed | Risk of conflicts |
| CI/CD Performance | Faster (cached), reliable | Slower, network dependent |

### File Structure

```json
{
  "version": 1,
  "isRoot": true,
  "tools": {
    "dotnet-ef": {
      "version": "8.0.11",
      "commands": ["dotnet-ef"]
    }
  }
}
```

Location: `/home/mbrewer/projects/koinon-rms/.config/dotnet-tools.json`

## Migration Detection Strategy

### Problem with Timestamps
```bash
# ❌ BAD: Unreliable, depends on file system state
MIGRATIONS=$(find src/Koinon.Infrastructure/Migrations -name "*.cs" -newer .git/FETCH_HEAD)
```

### Solution: Git-based Comparison
```bash
# ✅ GOOD: Reliable, git-aware, handles edge cases
git diff --name-only origin/main...HEAD -- "$MIGRATIONS_DIR/*.cs" | \
  grep -E "Migrations/[0-9]{14}_.*\.cs$" | \
  grep -v "\.Designer\.cs$" | \
  grep -v "ModelSnapshot\.cs$"
```

### Why This Works

1. **Compares Against Base Branch**
   - Uses three-dot syntax: `origin/main...HEAD`
   - Finds only changes introduced in your PR
   - Works with shallow clones and new branches

2. **Excludes Generated Files**
   - `.Designer.cs` - Generated by EF Core tools
   - `ModelSnapshot.cs` - Generated snapshot of model
   - Only checks actual migration definitions

3. **Validates Migration Pattern**
   - Timestamp format: `[0-9]{14}_` (e.g., `20251206041544_`)
   - Ensures file is actual migration, not stray .cs file
   - Case-sensitive to match EF Core conventions

4. **Graceful Fallback**
   - Returns empty list if no migrations found
   - Sets `migrations_found=false` for downstream jobs
   - No silent failures

## Comprehensive Destructive Change Detection

### The Problem
Original code only checked for 2 patterns:
```bash
grep -i "DropColumn\|DropTable"  # ❌ Incomplete
```

Missed:
- DropIndex (performance degradation)
- DropConstraint (data integrity issues)
- RenameTable/RenameColumn (application breakage)
- DropForeignKey (constraint violations)

### The Solution
Check for 10 destructive patterns:

```bash
DESTRUCTIVE_PATTERNS=(
  "DropTable"        # Entire table deleted
  "DropColumn"       # Column and data deleted
  "DropIndex"        # Index removed (performance impact)
  "DropConstraint"   # Constraint removed
  "DropForeignKey"   # Foreign key removed
  "DropPrimaryKey"   # Primary key removed
  "DropUnique"       # Unique constraint removed
  "RenameTable"      # Table renamed (breaking change)
  "RenameColumn"     # Column renamed (breaking change)
  "RenameIndex"      # Index renamed
)
```

### Detection Method

Checks actual C# method calls, not string patterns:
```bash
grep -n "migrationBuilder\.$pattern"
```

### Example Output

When destructive change detected:
```
⚠️ WARNING: Potentially destructive operation detected: DropColumn
Location:
+            migrationBuilder.DropColumn(
+                name: "legacy_field",
+                table: "person");

❌ DESTRUCTIVE MIGRATION DETECTED

This migration contains operations that may result in data loss:
- DropTable: Entire table and data removed
- DropColumn: Column and all data removed

REQUIRED: Please address one of the following:
1. Refactor migration to preserve data (e.g., archive instead of drop)
2. Add comment in migration explaining why data loss is acceptable
3. Update this job's DESTRUCTIVE_PATTERNS to exclude safe patterns
```

## Migration Validation Process

### Step 1: Tool Installation
```yaml
- name: Install local EF Core tools
  run: dotnet tool restore
```

Restores EF Core tools from `.config/dotnet-tools.json`

### Step 2: Migration Detection
```yaml
- name: Check for new migrations
  id: check-migrations
  run: |
    # Finds migrations comparing HEAD against origin/main
    # Sets output: migrations_found = true/false
```

### Step 3: Database Validation
```yaml
- name: Validate migrations can apply
  if: steps.check-migrations.outputs.migrations_found == 'true'
  run: |
    dotnet ef database update \
      --project src/Koinon.Infrastructure \
      --startup-project src/Koinon.Api \
      --verbose
```

**Why Validation Matters:**
- Verifies migration compiles
- Ensures DbContext is in sync with migrations
- Detects model configuration issues early
- Tests actual database application
- Fails fast before merge

### Step 4: Destructive Change Check
```yaml
- name: Check for destructive changes
  if: steps.check-migrations.outputs.migrations_found == 'true'
  run: |
    # Iterates through DESTRUCTIVE_PATTERNS
    # Fails job if any destructive operations found
    # Provides clear remediation steps
```

## Development Workflow

### Creating Migrations Locally

```bash
# Start services
docker-compose up -d postgres redis

# Create migration
dotnet ef migrations add AddNewFeatureTable \
  -p src/Koinon.Infrastructure \
  -s src/Koinon.Api

# Test migration
dotnet ef database update \
  -p src/Koinon.Infrastructure \
  -s src/Koinon.Api

# View applied migrations
dotnet ef migrations list \
  -p src/Koinon.Infrastructure \
  -s src/Koinon.Api

# Cleanup
docker-compose down -v
```

### Naming Conventions

**Migration Names:**
- PascalCase
- Descriptive (AddUserTable, DropLegacyField)
- Purpose-focused (not timestamp-focused)

**Examples:**
- ✅ `AddPersonPhoneNumbers`
- ✅ `CreateGroupMembershipTable`
- ✅ `ArchiveLegacyRecords`
- ❌ `UpdateDatabase`
- ❌ `Migration001`

## Handling Destructive Migrations

### Scenario 1: Retiring Legacy Column
**Problem:** Need to drop `legacy_status_id` column

**Solution Option 1: Archive Data**
```csharp
protected override void Up(MigrationBuilder migrationBuilder)
{
    // Create archive table for audit trail
    migrationBuilder.CreateTable(
        name: "person_legacy_status_archive",
        columns: table => new
        {
            person_id = table.Column<int>(),
            legacy_status_id = table.Column<int>(),
            archived_at = table.Column<DateTime>(),
            // ... audit fields
        });

    // Copy data before dropping
    migrationBuilder.Sql(
        "INSERT INTO person_legacy_status_archive (person_id, legacy_status_id, archived_at) " +
        "SELECT id, legacy_status_id, NOW() FROM person WHERE legacy_status_id IS NOT NULL");

    // Now safe to drop
    migrationBuilder.DropColumn("legacy_status_id", "person");
}
```

**Solution Option 2: Soft Delete**
```csharp
protected override void Up(MigrationBuilder migrationBuilder)
{
    // Rename instead of drop
    migrationBuilder.RenameColumn(
        name: "legacy_status_id",
        table: "person",
        newName: "_archived_legacy_status_id");

    // Track deprecation
    migrationBuilder.CreateIndex(
        name: "ix_person_archived_legacy_status",
        table: "person",
        column: "_archived_legacy_status_id");
}
```

### Scenario 2: Restructuring Table
**Problem:** Need to split `person_details` into separate tables

**Solution: Gradual Refactoring**
```csharp
// Migration 1: Create new normalized tables
protected override void Up(MigrationBuilder migrationBuilder)
{
    migrationBuilder.CreateTable("person_contact", ...);
    migrationBuilder.CreateTable("person_address", ...);
}

// Migration 2: Migrate data
protected override void Up(MigrationBuilder migrationBuilder)
{
    migrationBuilder.Sql("INSERT INTO person_contact SELECT ...");
    migrationBuilder.Sql("INSERT INTO person_address SELECT ...");
}

// Migration 3 (later): Drop old table after verification
protected override void Up(MigrationBuilder migrationBuilder)
{
    migrationBuilder.DropTable("person_details");
}
```

**Why Gradual?**
- Reduces rollback window
- Allows reverting without data loss
- Easier to debug issues
- Supports canary deployments

## CI/CD Integration Points

### GitHub Actions Workflow
Location: `.github/workflows/ci.yml`

```yaml
jobs:
  migration-check:
    if: github.event_name == 'pull_request'  # Only on PRs
    steps:
      # ... migration validation ...
      # Sets artifacts and outputs for downstream jobs
```

### Dependency Chain
```
Pull Request Created
    ↓
migration-check (runs on PR)
    ├─ Tool Restore
    ├─ Migration Detection
    ├─ Migration Validation
    └─ Destructive Check
        ↓
    [Passes] → PR reviews and merge
    [Fails] → Blocks merge, requires fixes
```

### Output Artifacts

None stored - validation is real-time. Benefits:
- No disk space usage
- Immediate feedback to developer
- No stale artifacts
- Clean workflow logs

## Troubleshooting Guide

### Problem: "tools restore failed"
```
Error: Unable to restore tool 'dotnet-ef'
```

**Causes & Solutions:**
1. Invalid `.config/dotnet-tools.json` format
   - Validate JSON syntax
   - Check version number format

2. Network issues
   - Check connectivity to nuget.org
   - Verify NuGet.org is accessible

3. Version doesn't exist
   - Verify version number at nuget.org/packages/dotnet-ef
   - Use `dotnet package search dotnet-ef --exact`

**Fix:**
```bash
# Validate locally
dotnet tool restore
dotnet ef --version
```

### Problem: "Migration validation failed"
```
Build FAILED. Microsoft.EntityFrameworkCore.Migrations.MigrationAssemblyMismatchException
```

**Causes & Solutions:**
1. DbContext out of sync with migrations
   - Check latest migration file
   - Run migrations locally first
   - Verify model hasn't changed

2. Database compatibility issues
   - Ensure PostgreSQL 16+ is running
   - Check connection string
   - Verify migrations can roll back

**Fix:**
```bash
# Test locally
docker-compose up -d postgres
dotnet ef database drop -p src/Koinon.Infrastructure -s src/Koinon.Api --force
dotnet ef database update -p src/Koinon.Infrastructure -s src/Koinon.Api
docker-compose down -v
```

### Problem: "Destructive migration blocked"
```
❌ DESTRUCTIVE MIGRATION DETECTED
⚠️ WARNING: Potentially destructive operation detected: DropColumn
```

**Solutions:**
1. Refactor to preserve data
   - Archive old column instead of dropping
   - Migrate data before dropping
   - Use soft-delete pattern

2. Add business justification
   - Comment in Up() method
   - Explain data loss acceptance
   - Link to approval process

3. Whitelist pattern (last resort)
   - Modify DESTRUCTIVE_PATTERNS array
   - Only if pattern is safe
   - Document reasoning

## Monitoring and Alerting

### Success Metrics
- Migration checks pass 100% (target)
- Zero failed validation errors
- Zero unreviewed destructive changes

### Watch For
- Increasing migration file size (refactor)
- Complex migrations (break into smaller ones)
- Frequent schema changes (review model)

### GitHub Checks

Each PR shows:
- ✅ Migration Safety Check PASSED
  - No migrations: Skipped (expected)
  - Valid migrations: Passed
  - No destructive changes: Clean

- ❌ Migration Safety Check FAILED
  - Tool restore failed: Check .config/dotnet-tools.json
  - Validation failed: Review migration code
  - Destructive changes: Refactor or document

## References

### Microsoft Docs
- [EF Core Migrations](https://docs.microsoft.com/en-us/ef/core/managing-schemas/migrations/)
- [EF Core Tools Reference](https://docs.microsoft.com/en-us/ef/core/cli/)
- [Global Tool Manifests](https://docs.microsoft.com/en-us/dotnet/core/tools/global-tools-how-to-use)

### Community Practices
- [Database Versioning Best Practices](https://wiki.postgresql.org/wiki/Suggested_core_contrib_changes#Schema_Versioning)
- [Migration Strategies](https://martinfowler.com/articles/evodb.html)

### Koinon Specific
- `.claude/GUARDRAILS.md` - Safety rules for code changes
- `CLAUDE.md` - Project conventions
- `docs/architecture.md` - System design decisions

## Summary Checklist

When creating migrations:
- [ ] Migration purpose is clear from name
- [ ] All changes are necessary for feature
- [ ] No drop operations without archive
- [ ] Migration tested locally with real data
- [ ] Down() method works correctly
- [ ] No hardcoded values that differ by environment
- [ ] Foreign key constraints properly defined
- [ ] Indexes added for foreign keys
- [ ] Database conventions followed (snake_case)
- [ ] Migration compiles without warnings

When reviewing migrations:
- [ ] Purpose aligns with PR
- [ ] No unnecessary data loss
- [ ] Backward compatibility maintained
- [ ] Performance impact analyzed
- [ ] Deployment order considered
- [ ] Rollback plan documented

---

**Last Updated:** 2025-12-06
**Status:** Active - Implemented in CI/CD
**Maintainers:** Development Team
